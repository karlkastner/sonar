% Mon Mar 24 10:39:05 WIB 2014
% Karl Kastner, Berlin
%
% TODO, there is a small bug, the header length is not computed correctly, see Chart 30_6_14 1657.slg sample 4000
%
% This programme is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This programme is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this programme. If not, see <https://www.gnu.org/licenses/>.
function obj = from_slg(obj, ifilename, echoflag, t0, FileID)

	if (nargin() < 3)
		echoflag = false;
	end

	if (nargin() < 5)
		FileID = 1;
	end

	% open input file
	fin = fopen(ifilename,'r');

	if (-1 == fin)
		error(['from_slg: Cannot open file :',ifilename,' for reading.']);
	end
	% read entire file at once
	data = fread(fin);
	fpos = 1;
	% close input file
	fclose(fin);

	% start time
	if (nargin() < 4 || isempty(t0))
		% try to scan t0 from file name
		[a b c base] = regexp(ifilename,'[^/]*$');
		base = base{1};
		[val count] = sscanf(base,'chart-%d-%d-%d-%d-%d.slg');
		if (5 == count)
			if (val(1) > 31)
				% y m d
				t0 = datenum(val(1),val(2),val(3),val(4),val(5),0);
			else
				% d m y
				t0 = datenum(val(3),val(2),val(1),val(4),val(5),0);
				
			end
		else
			t0 = 0;
			warning('No start time given, start time could not be parsed from file name');
		end
	end

	% read header
	obj.headerlen = 10;
	next       = uint8(fread_(fin,obj.headerlen,'uint8'));
	obj.header = next;
	if (length(next) < obj.headerlen)
		return;
	end

	% determine number of bytes per block
	obj.blocklen = 256*double(obj.header(6)) + double(obj.header(5));

	% read data for each ping individually
	pdx = 1;
	while (1)
		% load the entire block
		next = uint8(fread_(fin,obj.blocklen,'uint8'));
		% TODO, this is sloppy, length should be checked after each pos increase
		if (isempty(next))
			break;
		end
		% get the quality indicator bitmask
		obj.quality(pdx) =      double(next(1))      ...
				   +256*double(next(2));
		pos = 3;
		% analyse the quality indicator
		% note : location in header does not correspond with location in bitmask,
		% nor do they correspond with order in the slg2txt table
 		% unexplained bits: 0 1 2 3 _ 5 6 _ _ 9 _ 11 12  _ _ _
		%DepthV		11
		obj.DepthValid(pdx)        = bitand(obj.quality(pdx),2^11) > 0;
		%WTempV		4
		obj.WaterTempValid(pdx)    = bitand(obj.quality(pdx),2^4) > 0;
		%Temp2V ?
		obj.Temp2Valid(pdx) = 0;
		obj.Temp2(pdx) = obj.myNaN;
		%Temp3V	?
		obj.Temp3Valid(pdx) = 0;
		obj.Temp3(pdx) = obj.myNaN;
		%WSpdV		7
		obj.WaterSpeedValid(pdx)    = bitand(obj.quality(pdx),2^7) > 0;
		%PosV		2
		obj.PositionValid(pdx)      = bitand(obj.quality(pdx),2^2) > 0;
		%SurfaceDepth	10
		obj.SurfaceValid(pdx)       = bitand(obj.quality(pdx),2^10) > 0;
		%TopOfBottomDepth	10
		obj.TopOfBottomValid(pdx)   = bitand(obj.quality(pdx),2^10) > 0;
		%ColumnIs50kHz	15
		obj.ColumnIs50kHz(pdx)      = bitand(obj.quality(pdx),2^15) > 0;
		%TimeV		13
		obj.TimeValid(pdx)          = bitand(obj.quality(pdx),2^13) > 0;
		%SpdTrackV	8
		obj.SpeedTrackValid(pdx)    = bitand(obj.quality(pdx),2^8) > 0;
		%AltV		14
		obj.AltitudeValid(pdx)      = bitand(obj.quality(pdx),2^14) > 0;


		% TODO where is the UpperLimit stored ?
		obj.UpperLimit(pdx) = single(0.0);

		% read the lower limit
		% TODO (always valid or is there a quality flag?)
		obj.LowerLimit(pdx)  = typecast(next(pos:pos+3),'single');
		pos = pos+4;
		% read depth
 		% DepthV 1   - 5  ( 6 )
		%if (obj.DepthValid(pdx))
		% depth seems to be always stored, irrespecively, if the value is valid or not
			obj.Depth(pdx) = typecast(next(pos:pos+3),'single');
			pos = pos+4;
		%else
		%	obj.Depth(pdx) = obj.myNaN;
		%end

		% read water temperature
		if (obj.WaterTempValid(pdx))
			obj.WaterTemp(pdx) = typecast(next(pos:pos+3),'single');
			pos = pos+4;
		else
			obj.WaterTemp(pdx) = obj.myNaN;
		end

		% read WaterSpeed
		if (obj.WaterSpeedValid(pdx))
			obj.WaterSpeed(pdx) = typecast(next(pos:pos+3),'single');
			pos = pos+4;
		else
			obj.WaterSpeed(pdx) = NaN;
		end
	
		% read position
		if (obj.PositionValid(pdx))
			% y comes first
			obj.PositionY(pdx) = typecast(next(pos:pos+3),'int32');
			pos = pos+4;
			obj.PositionX(pdx) = typecast(next(pos:pos+3),'int32');
			pos = pos+4;
		else
			obj.PositionX(pdx) = obj.myNaN;
			obj.PositionY(pdx) = obj.myNaN;
		end

		% read surface Depth
		if (obj.SurfaceValid(pdx))
			obj.SurfaceDepth(pdx) = typecast(next(pos:pos+3),'single');
			pos = pos+4;
		else
			obj.SurfaceDepth(pdx) = obj.myNaN;
		end

		% read TopOfBottomDepth (5) or 6
		if (obj.TopOfBottomValid(pdx))
			obj.TopOfBottomDepth(pdx) = typecast(next(pos:pos+3),'single');
			pos = pos+4;
		else
			obj.TopOfBottomDepth(pdx) = obj.myNaN;
		end

		% read time offset
		if (obj.TimeValid(pdx))
			obj.TimeOffset(pdx) = typecast(next(pos:pos+3),'uint32');
			pos = pos+4;
		else
			obj.TimeOffset(pdx) = obj.myNaN;
			% TODO, this is a quick fix for postprocessing, no time, no position
			obj.PositionY(pdx) = obj.myNaN;
		end


		% read speed of track (2) 8 (14)
		if (obj.SpeedTrackValid(pdx))
			obj.Speed(pdx) = typecast(next(pos:pos+3),'single');
			pos = pos+4;
			obj.Track(pdx) = typecast(next(pos:pos+3),'single');
			pos = pos+4;
		else
			obj.Speed(pdx) = obj.myNaN;
			obj.Track(pdx) = obj.myNaN;
		end

		% read altitude (2) (8) 14
		if (obj.AltitudeValid(pdx))
			obj.Altitude(pdx) = typecast(next(pos:pos+3),'single');
			pos = pos+4;
		else
			obj.Altitude(pdx) = obj.myNaN;
		end

		for idx=1:20
			obj.single(pdx,idx)=typecast(next((3+4*(idx-1)):(3+4*idx)-1),'single');
			obj.int32(pdx,idx)=typecast(next((3+4*(idx-1)):(3+4*idx)-1),'int32');
		end

		% check that first echo is max (128), other values indicate incomplete parsing of header
		if (next(pos) ~= 128)
			fprintf(1,'Warning: First backscatter bin is not 128 for in %d in file %s\n',pdx,ifilename);
		end

		% tail is echo intensity
		obj.l(pdx) = pos-1;
		if (echoflag)
			obj.ECHO(1:min(length(next),obj.blocklen)-pos+1,pdx) = next(pos:end);
		end
		% next ping
		pdx = pdx+1;
	end % while(1)
	
	obj.to_metric(t0);

%	% somehow the depthValid information is sometimes bogus
%	% the depth can be assumed invalid, if it does not change
%	fdx = find(diff(obj.Depth) == 0)+1;
%	% invalidate samples where the depth did not change
%	obj.Depth(fdx) = NaN;

	% somehow the depthValid information is sometimes bogus
	% the depth can be assumed invalid, if it does not change
	obj.DepthHold  = [false; cvec(diff(obj.Depth) == 0)];
	obj.DepthValid = cvec(obj.DepthValid) & ~obj.DepthHold;
	% invalidate samples where the depth did not change
	obj.Depth(obj.DepthHold) = NaN;

	% interpolate the position values
	fdx = find(obj.PositionValid);
	% TODO, limit interpolation to time / distance
	if (length(fdx) > 1)
		try 
			obj.PositionX = interp1(double(obj.TimeOffset(fdx)),double(obj.PositionX(fdx)),double(obj.TimeOffset),obj.imethod);
			obj.PositionY = interp1(double(obj.TimeOffset(fdx)),double(obj.PositionY(fdx)),double(obj.TimeOffset),obj.imethod);
		catch
			warning('here');
		end
	end

	% convert coordinates to UTM
	[obj.wgs84.lat obj.wgs84.lon] = lowrance_mercator_to_wgs84(double(obj.PositionX),double(obj.PositionY));
	[obj.utm.X obj.utm.Y] = latlon2utm(obj.wgs84.lat, obj.wgs84.lon, obj.zone);
	
	obj.FileID = FileID*ones(size(obj.Depth));
	
	%fclose(fin);
	
	% at last the echo intensity has to be "stretched" according to the binsize
	obj.complete();

	function dat = fread_(fid,n,type)
		% data = fread(fid,n,type);
		dat  = data(fpos:min(fpos+n,length(data)));
		fpos = fpos+n;
	end
end % from_slg()

